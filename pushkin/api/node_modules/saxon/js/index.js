// Generated by CoffeeScript 2.3.2
var ReadStream, S_IFDIR, S_IFLNK, S_IFMT, S_IFREG, WriteStream, defer, errno, follow, fs, getMode, lstat, mkdir, os, path, readFile, readdir, readlink, resolve, stat, stream, uhoh, writeFile;

({lstat, mkdir, readdir, readlink, readFile, ReadStream, stat, writeFile, WriteStream} = require('graceful-fs'));

({S_IFMT, S_IFREG, S_IFDIR, S_IFLNK} = require('fs').constants);

errno = require('./errno');

path = require('path');

os = require('os');

fs = exports;

fs.stat = function(name) {
  return defer(stat, resolve(name));
};

fs.read = async function(name, enc) {
  var mode;
  name = resolve(name);
  if (!(mode = (await getMode(name)))) {
    uhoh(`Path does not exist: '${name}'`, 'NOT_REAL');
  }
  if (mode === S_IFDIR) {
    uhoh(`Path is not readable: '${name}'`, 'NOT_FILE');
  }
  if (enc === void 0) {
    enc = "utf8";
  }
  return defer(readFile, name, enc);
};

fs.list = async function(name) {
  var mode;
  name = resolve(name);
  if (!(mode = (await getMode(name)))) {
    uhoh(`Path does not exist: '${name}'`, 'NOT_REAL');
  }
  if (mode !== S_IFDIR) {
    uhoh(`Path is not a directory: '${name}'`, 'NOT_DIR');
  }
  return defer(readdir, name);
};

fs.follow = async function(name, recursive) {
  var mode;
  name = resolve(name);
  if (!(mode = (await getMode(name)))) {
    uhoh(`Path does not exist: '${name}'`, 'NOT_REAL');
  }
  if (mode === S_IFLNK) {
    return follow(name, recursive);
  } else {
    return Promise.resolve(name);
  }
};

fs.exists = async function(name) {
  return ((await getMode(resolve(name)))) !== null;
};

fs.isFile = async function(name) {
  return ((await getMode(resolve(name)))) === S_IFREG;
};

fs.isDir = async function(name) {
  return ((await getMode(resolve(name)))) === S_IFDIR;
};

fs.write = async function(name, content) {
  name = resolve(name);
  if (((await getMode(name))) !== S_IFDIR) {
    return defer(writeFile, name, content);
  }
  return uhoh(`Path is a directory: '${name}'`, 'NOT_FILE');
};

fs.mkdir = async function(name) {
  var mode;
  name = resolve(name);
  if (!(mode = (await getMode(name)))) {
    await fs.mkdir(path.dirname(name));
    return defer(mkdir, name);
  }
  // no-op if the directory already exists
  if (mode !== S_IFDIR) {
    return uhoh(`Path already exists: '${name}'`, 'PATH_EXISTS');
  }
};

fs.reader = function(name, opts) {
  return stream(ReadStream, name, opts);
};

fs.writer = function(name, opts) {
  return stream(WriteStream, name, opts);
};


// Internal

uhoh = function(msg, why) {
  var err;
  err = Error(msg);
  err.code = errno[why] || 0;
  Error.captureStackTrace(err, uhoh);
  throw err;
};

resolve = function(name) {
  if (name[0] === '~') {
    return os.homedir() + name.slice(1);
  } else {
    return path.resolve(name);
  }
};

getMode = async function(name) {
  var e;
  try {
    return ((await defer(lstat, name))).mode & S_IFMT;
  } catch (error) {
    e = error;
    return null;
  }
};

defer = function(callee, $1, $2) {
  var n;
  n = arguments.length - 1;
  return new Promise(function(resolve, reject) {
    var done;
    done = function(err, data) {
      if (err) {
        return reject(err);
      } else {
        return resolve(data);
      }
    };
    switch (n) {
      case 0:
        return callee(done);
      case 1:
        return callee($1, done);
      case 2:
        return callee($1, $2, done);
    }
  });
};

// Recursive symlink resolution
follow = function(link, recursive) {
  return new Promise(function(resolve, reject) {
    var next, prev, reads, validate;
    prev = link;
    reads = 1;
    if (typeof recursive === 'function') {
      validate = recursive;
      recursive = true;
    }
    return readlink(link, next = async function(err, name) {
      var mode;
      if (err) {
        return reject(err);
      }
      if (!path.isAbsolute(name)) {
        name = path.resolve(path.dirname(prev), name);
      }
      if (validate && !((await validate(name)))) {
        return resolve(prev);
      } else if (!recursive) {
        return resolve(name);
      } else if (!(mode = (await getMode(name)))) {
        err = Error(`Symlink leads nowhere: '${link}'`);
        err.code = errno.NOT_REAL;
        return reject(err);
      } else if (mode !== S_IFLNK) {
        return resolve(name);
      } else if (reads !== 10) {
        prev = name;
        reads++;
        return readlink(name, next);
      } else {
        err = Error(`Too many symlinks: '${link}'`);
        err.code = errno.LINK_LIMIT;
        return reject(err);
      }
    });
  });
};

stream = function(ctr, name, opts) {
  if (typeof name === 'number') {
    opts && (opts.fd = name);
    return new ctr(null, opts || {
      fd: name
    });
  } else {
    return new ctr(resolve(name), opts);
  }
};

(function() {  // Expose error codes.
  var def, des, why;
  def = Object.defineProperty;
  des = {
    value: 0
  };
  for (why in errno) {
    des.value = errno[why];
    def(fs, why, des);
  }
})();
