"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _express = _interopRequireDefault(require("express"));

var _rpc = _interopRequireDefault(require("./rpc.js"));

var _trim = _interopRequireDefault(require("./trim.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ControllerBuilder = /*#__PURE__*/function () {
  function ControllerBuilder() {
    _classCallCheck(this, ControllerBuilder);

    this.passAlongs = [];
    this.directUses = [];
    this.validHttpMethods = ['get', 'post', 'put', 'delete'];
  } // pass posts/gets/puts/deletes on this route to this method via this queue


  _createClass(ControllerBuilder, [{
    key: "setPass",
    value: function setPass(route, rpcMethod, queue, httpMethod) {
      httpMethod = httpMethod || 'post';

      if (this.validHttpMethods.indexOf(httpMethod) < 0) {
        console.error("'".concat(httpMethod, "' is not a valid http method. Ignoring for route ").concat(route));
        return;
      }

      this.passAlongs.push({
        route: route,
        rpcMethod: rpcMethod,
        queue: queue,
        httpMethod: httpMethod
      });
    } // allow users to set their own custom api endpoints that just pass things along

  }, {
    key: "setCustomPass",
    value: function setCustomPass(route, handler, queue, httpMethod) {
      httpMethod = httpMethod || 'post';

      if (this.validHttpMethods.indexOf(httpMethod) < 0) {
        console.error("'".concat(httpMethod, "' is not a valid http method. Ignoring for route ").concat(route));
        return;
      }

      this.passAlongs.push({
        route: route,
        rpcMethod: rpcMethod,
        queue: queue,
        httpMethod: httpMethod
      });
    } // allow users to set their own custom api endpoints that don't just pass things along

  }, {
    key: "setDirectUse",
    value: function setDirectUse(route, handler, httpMethodOption) {
      var httpMethod = httpMethodOption == undefined ? 'post' : httpMethodOption;
      this.directUses.push({
        httpMethod: httpMethod,
        route: route,
        handler: handler
      });
    }
  }, {
    key: "setDefaultPasses",
    value: function setDefaultPasses(readQueue, writeQueue, taskQueue) {
      this.setPass('/tabulateAndPostResults', 'tabulateAndPostResults', taskQueue, 'post');
      this.setPass('/startExperiment', 'startExperiment', taskQueue, 'post');
      this.setPass('/getStimuli', 'getStimuli', readQueue, 'post');
      this.setPass('/insertMetaResponse', 'insertMetaResponse', writeQueue, 'post');
      this.setPass('/stimulusResponse', 'insertStimulusResponse', writeQueue, 'post');
      this.setPass('/endExperiment', 'endExperiment', taskQueue, 'post');
    }
  }, {
    key: "getConnFunction",
    value: function getConnFunction() {
      var _this = this;

      return function (conn) {
        var router = new _express["default"].Router();

        _this.passAlongs.forEach(function (point) {
          return router[point.httpMethod](point.route, function (req, res, next) {
            // eslint-disable-line
            console.log("".concat(point.httpMethod.toUpperCase(), " ").concat(point.route, " hit (in router conn function)"));
            console.log(req.body);
            var rpcParams = {
              method: point.rpcMethod,
              data: req.body,
              params: req.params,
              sessionId: req.session.id
            };
            (0, _rpc["default"])(conn, point.queue, rpcParams).then(function (rpcRes) {
              try {
                console.log("".concat(point.rpcMethod, " method rpc response: ").concat((0, _trim["default"])(JSON.stringify(rpcRes), 100)));
              } catch (e) {
                console.log("".concat(point.rpcMethod, " method rpc response (failed to JSON.stringify): ").concat((0, _trim["default"])(rpcRes, 100)));
              }

              res.send({
                resData: rpcRes
              });
            })["catch"](function (rpcErr) {
              console.error("Error in API getting RPC response: ".concat(rpcErr));
              res.status(500).send(rpcErr);
            });
          });
        });

        _this.directUses.forEach(function (point) {
          return router[point.httpMethod](point.route, point.handler);
        });

        return router;
      };
    }
  }]);

  return ControllerBuilder;
}();

exports["default"] = ControllerBuilder;